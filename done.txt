KMP:
-naive implementation
-regular implementation+nextTable

-testing: single run with timing, multiple runs and comparing results, generating random valid input

-problems: naive implementation and string "aaaa", with pattern "aa" 
    kmp matches, where the algo continues

AhoC:


-problems: string.ascii_uppercase + string.digits as possible chars
    how many states, for now using upper limit and some are empty -> trie
    implementation of goTo function, whole alphabet vs hashing/dict
    checking on input-> multiple times the same word

RabinKarp:
    -only working on 1 and 0
    -> diffrent version from http://www-igm.univ-mlv.fr/~lecroq/string/node5.html#SECTION0050
    -for speed try byteshift vs 2*


more testing
boyer-moore

kmp standard
rk test without many occurencsy faster

alternativ: union-find implemntation refresh 




TESTS:
-ahoc: printable instead of uppercase+didigts


BM:
-diffrent versions: badChar as single array or 2d array
-https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bm.htm
vs http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140

boyer moore,turbo boyer more,apostolico.giancarlo -> diffrent variants, compare against
https://www.amazon.de/Handbook-Exact-String-Matching-Algorithms/dp/0954300645
https://www.amazon.de/Algorithms-Strings-Maxime-Crochemore/dp/1107670993/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=&sr=

-> focus on booyer more handbook of exact STring Matching
small presentaioon, compare the implemntation, speed on diffrent data

Data: len(text), len(pattern), size(alphabet), preprocssing->remove by only on dataset at times

runs at x-asis, time at y-axis -> diffrent lines

LONG TERM GOAL:
pattern matching with variabls:
regular patterns

oder



REPORT:
ENGLISH

describe genau welche Algorithms, einzelheiten
challenges
theoretical comparison/practical

tests:
-data
-issus with data/dataset, size/randomness
results on dataset
in 2 weeks:



24.01.21:

- canonical form rework, in first version just renamed each variable, but problem when one variable occured multiple times, so createt conversion dict to store which old names matches the new one.
- isRegularPatternClass key idea very simple, just check for duplicates, but how to implement, collect each one and search whether its already there? for now iterate over all possible variables, since its only the uppercase letters
- implementation of algo 1:
    - replaceAt is used to maintain the old pattern while testing new ones
    - look at descPat, isRegularPatternClass not needed at all
    - problem with matchingRegular, prefix vs middle part vs suffix, what happends when pattern end on a variable and suffix is empty, also rework of findAllNonVariables to separate between suffix,prefix and the results
    - suffix problem for empty suffix

    - algo working, but is it correct?, is descriptive pattern unique or can there be multiple equaliy once
    - how to rate patterns, distance zwischen pattern
    
27.01:
- trimming the finale pattern, for sequence of variables like GGEGJ -> G, should that be in the canonical form?


"""

bis 27.01 regular fertig - done
dann nächste pattern types
dann real data test

BA struktur:
literatur/erklärungen
implementation beschreiben
test cases
analyse + diagramme

# matching algorithm
# shinohara erklären
# den shinohara algorithmus erklären
# testclassen beschreiben
# über meine implementierung 


meeting 27.01:
distance zwischen pattern:
    lcs longest common substring als metric
    split verfahren
    andere verfahren?
    number of letters/ number of variables
        prefix/sufix test trivial oder?

    -> statisticen zu metriken

warten auf biodaten, 
non cross pattern



done am 03.02:
-> generateRegularPattern and generateWordsFromPattern, problem in generateRegularPattern, multiple vars in a row are possibke
-> newTest
-> metrics for new test, first the one by generating words from the old pattern and checking if the new one gets it -> metricByWordMatching
    but already problem case: original: vjABjciihCayDktEynlz , algorithm build vjAnBlCz , so new new pattern accepts all generated words
    remeber the goal was not to find orginial pattern, its to find descriptive pattern of sample
    so finding all words doesnt mean the algoritm found the descriptive pattern
    this example:   ABarfmrCiawpyDErxtte
                    AeBe        -> new pattern is not descriptive, but where is the problem, sample size or mistake in algorithm

                    with fixed pattern but varing sample the algo produces: AaBrfmrCiawpyDrxtte, AiaBrCxtte, AtBtCe

    -> overall metric not effictive, since all words can be found, even if the new pattern is far from being descriptive, or is it descriptive

    -> lcs implemented
    -> fixed problem with generateRegularPattern, since it build pattern with variables directly after each other, which are regular, so it should be possible???

    TODO: clean up canonical form, where should it be


Meeting 03.02:
overfitting, wenn pattern zu spezifisch -> generierte samples zu ähnlich

oder pattern nicht spezifisch genug
Is a aXb b bbYca c an instance of a X b Y c -> instance check

ab wie vielen anteil der menge klappt das wort
bei welchem anteil wörter in der generation wird welcher anteil erkannt-> graph für arbeit

suffix arrays -> ababa X absda Y asda sX uhasudha X Z -> k-repeated-variable
one repeated -> 1 ne var darf sich wiederholen, die andern nicht

handgeschrieben testcases
"""

am 19.02:
-organisation in eigene files nach funktion, es steht:
    util für zustandslose funktion zur umwandelung oder spezifischen abfragen
    generate für alle func die random benutzen und daten erzeugen
    patternLanguage für die hauptfunktionen
    testing für ergbnisse unter benutzeung von generate


    TODO:
    debugging ob reg pattern fertig sind
    nächste pattern class

    beurteilen der erzeugten pattern frage-> die metriken

Outputs:

Generated Pattern:  AhBrxgnqCe
Generated Sample:  ['pgdfhmvqrxgnqeeue', 'pxvhitprxgnqvgeje', 'xmhhtniherxgnqnbne', 'wsocqhogtrxgnqgqke', 'rqzkthbdhrxgnqftwfce', 'gvchhdmfxrxgnqrele', 'nlxahhvnrxgnqwnxze', 'pwvhdojckrxgnqdjdlge', 'qxycdhtxvhrxgnqtoie', 'jmrlhdyorxgnqapoee', 'umokhndorxgnqmoarde', 'pbrhxypuerxgnqlgge', 'oyopqhnierxgnqyjhse', 'vlfhwlevrxgnqlljqve', 'jtqfhjugrxgnqzrape', 'xynhnbixprxgnqjvqke', 'qzknehewxrxgnqrlpte', 'bjnihhudrxgnqryxce', 'bzvwjhaokyrxgnquosgqe', 'pseazhvffrxgnqzvne']
Build Pattern:  AgBqCeDe
LCS:  0.3
WordMatching:  1.0

-> algo found a different pattern, but it was able to match all words

Generated Pattern:  zwAnBuwvs
Generated Sample:  ['zwcpxkneexecuwvs', 'zwxdvnkpoluwvs', 'zwivtnitpuwvs', 'zwtvxxnaqicuwvs', 'zwwwhhnwkmfyuwvs', 'zwkbanxqguwvs', 'zwrzqncxjtuwvs', 'zwpjpynybhuluwvs', 'zwsjdnmtgkuuwvs', 'zwzkydontmqquwvs', 'zwhvknmkkuwvs', 'zwhmenfhnxpuwvs', 'zwzmkhrnfbvoouwvs', 'zwwwnnsbgzuwvs', 'zwadlhfnqlsuwvs', 'zwyvplnvghqyuwvs', 'zwwilinnsxluwvs', 'zwkvdynltpiauwvs', 'zwtoznzfwhuwvs', 'zwoabfhnyacquwvs']
Build Pattern:  zwAvBs 

LCS:  0.3333333333333333
WordMatching:  1.0
-> result is less specific

Generated Pattern:  uesnwAfa
Generated Sample:  ['uesnwsiufa', 'uesnwreqfa', 'uesnwmuijfa', 'uesnwgcbsufa', 'uesnwttzfa', 'uesnwkduffa', 'uesnwaawxfa', 'uesnwkhbfa', 'uesnwlrxokfa', 'uesnwsoifa', 'uesnwiwpfa', 'uesnwoffufa', 'uesnwntlwfa', 'uesnwntrfa', 'uesnwrzaujfa', 'uesnwfymefa', 'uesnwqoepfa', 'uesnwrkllfa', 'uesnwpxxxyfa', 'uesnwrlitfa']
Build Pattern:  uesnwAfa
LCS:  1.0
WordMatching:  1.0
-> sometimes it works

-> lcs is more suitable then wordmatching
by increasing the sample size it should be more likely that it works
-> build a graph with changing size of sample for algo



03.03:
- findMaximalTerminalFactors done

Meeting:
- one repeated, biodaten woher -> https://pad.gwdg.de/-c7GRdLgTtG4-3CAps-Ocw?both

suchen in großem datensatz, suchen nach start und endsequenz die in allen gleich ist

finden von motifs


start und stop sequenzen https://www.news-medical.net/life-sciences/START-and-STOP-Codons.aspx



24.03:
problem with descPat when all input words are the same

05.05:
debugging with bio data:
- first data must be lowercase to work -> easy fix
- second problem is number of variables needs to be smaller then 26 to work with the letters of the alphabet -> try splitting in 25er blocks
    -> next how to split and how to store the blocks

28.05:
integar arrays

anzahl variablen nach organismen
statistken auf den pattern

häflte der organismen zum erzeugen von pattern
dann testen ob die anderen dazu passen
je nach verhältnis lernen 


oder andere pattern art

FREITAG der 4.06 12 uhr


Work am 03.06
-int array working check, but implement everywhere
now back to bio, how to import datasets-> importing works into an intArray
now fixing all old functions, already problem with canonical form -> done was easy
in patternLanguage, switching from string based to list based-> problem with copying of list and changes in the copy and references
looks good for now, but testing not confirmed

what should the generation do now, for now only change is to output in intArray form, without changing the underlying generation

bit happy smily for descPat working so easy :D :D

another rework for path